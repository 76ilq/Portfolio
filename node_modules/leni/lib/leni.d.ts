declare type PostMessageAble = {
    postMessage: typeof Worker['prototype']['postMessage'];
};
export declare type SubscriptionCallback = (emitter: Emitter) => void;
interface EventListener<T = any> {
    (evt: CustomEvent<T>): void;
}
interface EventListenerObject<T = any> {
    handleEvent(object: CustomEvent<T>): void;
}
declare type EventListenerOrEventListenerObject<T = any> = EventListener<T> | EventListenerObject<T>;
declare class BaseEmitter extends EventTarget {
    #private;
    constructor(tag: string, channel: PostMessageAble, id?: number);
    handleEvent(ev: MessageEvent): void;
    respond(ev: AsyncEvent<any>, data: any): void;
    post<T = any>(type: string, data: T): void;
    postAsync<T = any, R = any>(type: string, data: T): Promise<R>;
    disconnect(): void;
    stopListening(): void;
}
export declare type Emitter = BaseEmitter & {
    addEventListener<T = any>(type: string, callback: EventListenerOrEventListenerObject<T> | null, options?: boolean | AddEventListenerOptions | undefined): void;
    addEventListener(type: string, callback: EventListenerOrEventListenerObject<any> | null, options?: boolean | AddEventListenerOptions | undefined): void;
};
declare function connect(tag: string, worker: Worker): Emitter;
export declare class AsyncEvent<T> extends CustomEvent<T> {
    promise: null | Promise<any>;
    eid: string | undefined;
    respondWith<R = any>(promise: Promise<R>): void;
}
declare function subscribe(tag: string, cb: SubscriptionCallback): void;
export { connect, subscribe };
