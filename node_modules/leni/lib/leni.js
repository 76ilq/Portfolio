const spec = '_leni-tag';
const MSG = 1;
const DEL = 2;
const PRM = 3;
let globalId = 0;
const _postSym = Symbol('post');
class BaseEmitter extends EventTarget {
    #tag;
    #channel;
    #id;
    #s = true;
    #m = new Map();
    constructor(tag, channel, id) {
        super();
        this.#tag = tag;
        this.#channel = channel;
        if (typeof id === 'undefined') {
            id = (globalId = globalId + 1);
        }
        this.#id = id;
    }
    handleEvent(ev) {
        let msg = ev.data || {};
        if (msg.spec === spec && msg.id === this.#id && this.#s) {
            switch (msg.stype) {
                case MSG: {
                    this.dispatchEvent(new CustomEvent(msg.type, {
                        detail: msg.data
                    }));
                    break;
                }
                case PRM: {
                    let resolve = this.#m.get(msg.eid);
                    resolve(msg.data);
                    this.#m.delete(msg.eid);
                    break;
                }
            }
        }
    }
    respond(ev, data) {
        let eid = ev.eid;
        this.#channel.postMessage({
            spec, data, eid,
            stype: PRM,
            id: this.#id,
            tag: this.#tag
        });
    }
    post(type, data) {
        this.#channel.postMessage({
            spec, type, data,
            stype: MSG,
            id: this.#id,
            tag: this.#tag
        });
    }
    async postAsync(type, data) {
        let eid = Math.random();
        let resolve;
        let p = new Promise(r => resolve = r);
        this.#channel.postMessage({
            spec, type, data,
            stype: MSG,
            id: this.#id,
            eid,
            tag: this.#tag
        });
        this.#m.set(eid, resolve);
        return p;
    }
    disconnect() {
        this.#channel.postMessage({
            spec,
            stype: DEL,
            id: this.#id
        });
    }
    stopListening() {
        this.#s = false;
        this.disconnect();
    }
}
function connect(tag, worker) {
    let e = new BaseEmitter(tag, worker);
    worker.addEventListener('message', e);
    return e;
}
export class AsyncEvent extends CustomEvent {
    promise = null;
    eid;
    respondWith(promise) {
        this.promise = promise;
    }
}
function subscribe(tag, cb) {
    let idMap = new Map();
    self.addEventListener('message', (ev) => {
        let msg = ev.data || {};
        if (msg.spec === spec && msg.tag === tag) {
            switch (msg.stype) {
                case MSG: {
                    let emitter = idMap.get(msg.id);
                    if (!emitter) {
                        emitter = new BaseEmitter(tag, self, msg.id);
                        cb(emitter);
                        idMap.set(msg.id, emitter);
                    }
                    let ev = new AsyncEvent(msg.type, {
                        detail: msg.data
                    });
                    ev.eid = msg.eid;
                    emitter.dispatchEvent(ev);
                    if (msg.eid && ev.promise) {
                        ev.promise.then(val => {
                            emitter?.respond(ev, val);
                        });
                    }
                    break;
                }
                case DEL: {
                    idMap.delete(msg.id);
                    break;
                }
            }
        }
    });
}
export { connect, subscribe };
